#!/usr/bin/env node

/**
 * Main generation orchestrator for Xibo CMS SDK
 * Generates TypeScript types from Swagger 2.0 specification
 * Location: scripts\generate-types.js
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const SWAGGER_FILE = 'expected-data-results/xibo-cms-develop-swagger.json';
const OUTPUT_FILE = 'src/generated/types/swagger-types.ts';
const POST_PROCESS_SCRIPT = 'scripts/post-process-types.js';

console.log('ðŸš€ Starting Xibo CMS SDK Type Generation...');

// Step 1: Validate Swagger file exists
if (!fs.existsSync(SWAGGER_FILE)) {
  console.error(`âŒ Swagger file not found: ${SWAGGER_FILE}`);
  process.exit(1);
}

console.log(`âœ… Found Swagger file: ${SWAGGER_FILE}`);

// Step 2: Create output directory if it doesn't exist
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
  console.log(`ðŸ“ Created output directory: ${outputDir}`);
}

// Step 3: Generate types manually from Swagger 2.0 definitions
console.log('ðŸ”„ Generating TypeScript types from Swagger 2.0...');
try {
  // Read and parse the Swagger file
  const swaggerContent = fs.readFileSync(SWAGGER_FILE, 'utf8');
  const swagger = JSON.parse(swaggerContent);
  
  if (!swagger.definitions) {
    throw new Error('No definitions found in Swagger file');
  }
  
  console.log(`Found ${Object.keys(swagger.definitions).length} definitions to convert`);
  
  // Generate TypeScript interfaces from Swagger definitions
  const generatedTypes = generateTypesFromSwagger(swagger);
  
  // Write to output file
  fs.writeFileSync(OUTPUT_FILE, generatedTypes, 'utf8');
  
  console.log(`âœ… Generated types to: ${OUTPUT_FILE}`);
} catch (error) {
  console.error('âŒ Failed to generate types:', error.message);
  process.exit(1);
}

// Step 4: Run post-processing script
console.log('ðŸ”„ Running post-processing transformations...');
try {
  const command = `node ${POST_PROCESS_SCRIPT}`;
  console.log(`Running: ${command}`);
  
  execSync(command, { 
    stdio: 'inherit',
    cwd: process.cwd()
  });
  
  console.log('âœ… Post-processing completed');
} catch (error) {
  console.error('âŒ Post-processing failed:', error.message);
  process.exit(1);
}

// Step 5: Verify generated file
if (!fs.existsSync(OUTPUT_FILE)) {
  console.error(`âŒ Generated file not found: ${OUTPUT_FILE}`);
  process.exit(1);
}

const stats = fs.statSync(OUTPUT_FILE);
console.log(`âœ… Generated file size: ${(stats.size / 1024).toFixed(2)} KB`);

console.log('ðŸŽ‰ Type generation completed successfully!');
console.log('');
console.log('Next steps:');
console.log('1. Review the generated types in src/generated/types/swagger-types.ts');
console.log('2. Run `npm run build` to verify types compile correctly');
console.log('3. Create enhanced runtime models that use these generated types');

/**
 * Convert Swagger 2.0 property definition to TypeScript type
 */
function swaggerTypeToTS(property, definitions = {}) {
  if (!property) return 'any';
  
  // Handle $ref references
  if (property.$ref) {
    const refName = property.$ref.replace('#/definitions/', '');
    return refName;
  }
  
  // Handle arrays
  if (property.type === 'array') {
    if (property.items) {
      const itemType = swaggerTypeToTS(property.items, definitions);
      return `${itemType}[]`;
    }
    return 'any[]';
  }
  
  // Handle objects with properties
  if (property.type === 'object' && property.properties) {
    const props = Object.entries(property.properties).map(([key, prop]) => {
      const optional = property.required && property.required.includes(key) ? '' : '?';
      const type = swaggerTypeToTS(prop, definitions);
      return `  ${key}${optional}: ${type};`;
    }).join('\n');
    return `{\n${props}\n}`;
  }
  
  // Handle basic types
  switch (property.type) {
    case 'integer':
    case 'number':
      return 'number';
    case 'string':
      // Handle enums
      if (property.enum) {
        return property.enum.map(val => `'${val}'`).join(' | ');
      }
      return 'string';
    case 'boolean':
      return 'boolean';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

/**
 * Generate TypeScript interfaces from Swagger 2.0 definitions
 */
function generateTypesFromSwagger(swagger) {
  const { definitions } = swagger;
  
  let output = `/**
 * Generated TypeScript types from Xibo CMS Swagger 2.0 specification
 * Location: src\\generated\\types\\swagger-types.ts
 * 
 * âš ï¸  DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated from the Swagger specification.
 * Run 'npm run generate:types' to regenerate.
 * 
 * Generated on: ${new Date().toISOString()}
 */

`;

  // Generate interfaces for each definition
  Object.entries(definitions).forEach(([name, definition]) => {
    // Add JSDoc comment if description exists
    if (definition.description) {
      output += `/**\n * ${definition.description}\n */\n`;
    }
    
    output += `export interface ${name} {\n`;
    
    if (definition.properties) {
      Object.entries(definition.properties).forEach(([propName, property]) => {
        // Add JSDoc for property if description exists
        if (property.description) {
          output += `  /**\n   * ${property.description}\n   */\n`;
        }
        
        // Determine if property is optional
        const isRequired = definition.required && definition.required.includes(propName);
        const optional = isRequired ? '' : '?';
        
        // Convert property type
        const tsType = swaggerTypeToTS(property, definitions);
        
        output += `  ${propName}${optional}: ${tsType};\n`;
      });
    }
    
    // Handle allOf (inheritance)
    if (definition.allOf) {
      definition.allOf.forEach(item => {
        if (item.$ref) {
          const refName = item.$ref.replace('#/definitions/', '');
          output += `  // Extends ${refName}\n`;
        } else if (item.properties) {
          Object.entries(item.properties).forEach(([propName, property]) => {
            const isRequired = item.required && item.required.includes(propName);
            const optional = isRequired ? '' : '?';
            const tsType = swaggerTypeToTS(property, definitions);
            output += `  ${propName}${optional}: ${tsType};\n`;
          });
        }
      });
    }
    
    output += `}\n\n`;
  });

  // Add utility types
  output += `/**
 * Utility types for API responses
 */
export interface PaginatedResponse<T> {
  data: T[];
  total?: number;
  page?: number;
  pageSize?: number;
  hasNext?: boolean;
  hasPrevious?: boolean;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

/**
 * Common request parameters
 */
export interface SearchParams {
  start?: number;
  length?: number;
  order?: string;
  sort?: string;
  filter?: string;
}

export interface DisplaySearchParams extends SearchParams {
  display?: string;
  displayGroup?: string;
  authorised?: number;
  tags?: string;
  exactTags?: number;
  loggedIn?: number;
  lastAccessed?: string;
  embed?: string;
}

export interface LayoutSearchParams extends SearchParams {
  layout?: string;
  userId?: number;
  retired?: number;
  tags?: string;
  exactTags?: number;
  ownerUserGroupId?: number;
  layoutId?: number;
  embed?: string;
}

export interface CampaignSearchParams extends SearchParams {
  campaignId?: number;
  name?: string;
  tags?: string;
  exactTags?: number;
  layoutId?: number;
  hasLayouts?: number;
  isLayoutSpecific?: number;
  embed?: string;
}
`;

  return output;
}
