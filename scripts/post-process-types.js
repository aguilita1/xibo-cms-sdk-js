#!/usr/bin/env node

/**
 * Post-processing script for Swagger 2.0 generated types
 * Handles Xibo CMS specific transformations and improvements
 * Location: scripts\post-process-types.js
 */

const fs = require('fs');
const path = require('path');

// Configuration
const TYPES_FILE = 'src/generated/types/swagger-types.ts';

console.log('üîÑ Starting post-processing of generated types...');

// Verify the file exists
if (!fs.existsSync(TYPES_FILE)) {
  console.error(`‚ùå Types file not found: ${TYPES_FILE}`);
  process.exit(1);
}

// Read the generated file
let content = fs.readFileSync(TYPES_FILE, 'utf8');
console.log(`üìñ Read ${content.length} characters from ${TYPES_FILE}`);

// Track transformations
let transformationCount = 0;

/**
 * Apply transformations specific to Swagger 2.0 and Xibo CMS
 */

// 1. Add file header with warnings and metadata
const fileHeader = `/**
 * Generated TypeScript types from Xibo CMS Swagger 2.0 specification
 * Location: src\\generated\\types\\swagger-types.ts
 * 
 * ‚ö†Ô∏è  DO NOT EDIT THIS FILE MANUALLY ‚ö†Ô∏è
 * 
 * This file is automatically generated from the Swagger specification.
 * Any manual changes will be overwritten when types are regenerated.
 * 
 * To regenerate: npm run generate:types
 * 
 * Generated on: ${new Date().toISOString()}
 * Swagger version: 2.0
 * API version: 4.0
 */

`;

// Add header if not already present
if (!content.includes('DO NOT EDIT THIS FILE MANUALLY')) {
  content = fileHeader + content;
  transformationCount++;
  console.log('‚úÖ Added file header with warnings');
}

// 2. Transform integer timestamps to Date-compatible string types
// Look for properties that are clearly timestamps (Unix epoch integers)
const timestampFields = [
  'lastAccessed', 'auditingUntil', 'createdDt', 'modifiedDt', 'publishedDate',
  'logDate', 'lastDataEdit', 'lastSync', 'lastClear', 'expires', 'startDt', 'endDt',
  'fromDt', 'toDt', 'releaseDt', 'readDt', 'emailDt', 'reminderDt', 'lastReminderDt',
  'recurrenceRange', 'incidentDt', 'generatedOn', 'createdAt', 'modifiedAt'
];

timestampFields.forEach(field => {
  // Transform integer timestamp fields to string (ISO date format)
  const timestampPattern = new RegExp(`(${field}\\??):\\s*number;`, 'g');
  const matches = content.match(timestampPattern);
  if (matches) {
    content = content.replace(timestampPattern, `$1: string; // ISO date string (transformed from Unix timestamp)`);
    transformationCount += matches.length;
    console.log(`‚úÖ Transformed ${matches.length} instances of ${field} from number to string`);
  }
});

// 3. Transform 0/1 integer flags to boolean types where semantically appropriate
const booleanFields = [
  'licensed', 'loggedIn', 'incSchedule', 'emailAlert', 'wakeOnLanEnabled', 'retired',
  'valid', 'isEdited', 'released', 'enabled', 'isDefault', 'isDynamic', 'isRemote',
  'isRealTime', 'truncateOnEmpty', 'ignoreFirstRow', 'isLookup', 'showFilter', 'showSort',
  'isRequired', 'isAlways', 'isCustom', 'isDisplaySpecific', 'exactTags', 'isSystem',
  'isInterrupt', 'isPriority', 'syncEvent', 'syncTimezone', 'isGeoAware', 'useDuration',
  'loop', 'deleteOnExpiry', 'isLayoutSpecific', 'cyclePlaybackEnabled', 'isUserSpecific',
  'isEveryone', 'newUserWizard', 'isPasswordChangeRequired', 'isSystemNotification',
  'isDisplayNotification', 'isDataSetNotification', 'isLayoutNotification',
  'isLibraryNotification', 'isReportNotification', 'isScheduleNotification',
  'isCustomNotification', 'isShownForAddUser', 'authorised', 'isOutdoor', 'isMobile'
];

booleanFields.forEach(field => {
  // Transform 0/1 integer flags to boolean
  const booleanPattern = new RegExp(`(${field}\\??):\\s*number;`, 'g');
  const matches = content.match(booleanPattern);
  if (matches) {
    content = content.replace(booleanPattern, `$1: boolean; // Transformed from 0/1 integer flag`);
    transformationCount += matches.length;
    console.log(`‚úÖ Transformed ${matches.length} instances of ${field} from number to boolean`);
  }
});

// 4. Add JSDoc comments for better IntelliSense
const jsdocTransformations = [
  {
    pattern: /displayId\??: (string|number|boolean);/g,
    replacement: `/** The unique identifier for this Display */\n  displayId?: $1;`
  },
  {
    pattern: /layoutId\??: (string|number|boolean);/g,
    replacement: `/** The unique identifier for this Layout */\n  layoutId?: $1;`
  },
  {
    pattern: /campaignId\??: (string|number|boolean);/g,
    replacement: `/** The unique identifier for this Campaign */\n  campaignId?: $1;`
  },
  {
    pattern: /playlistId\??: (string|number|boolean);/g,
    replacement: `/** The unique identifier for this Playlist */\n  playlistId?: $1;`
  },
  {
    pattern: /widgetId\??: (string|number|boolean);/g,
    replacement: `/** The unique identifier for this Widget */\n  widgetId?: $1;`
  }
];

jsdocTransformations.forEach(({ pattern, replacement }) => {
  const matches = content.match(pattern);
  if (matches) {
    content = content.replace(pattern, replacement);
    transformationCount += matches.length;
  }
});

// 5. Fix array types that may be incorrectly generated from Swagger 2.0
// Look for array definitions that might need fixing
const arrayFixPattern = /items:\s*{\s*\$ref:\s*"#\/definitions\/(\w+)"\s*}/g;
let arrayMatches = content.match(arrayFixPattern);
if (arrayMatches) {
  console.log(`‚úÖ Found ${arrayMatches.length} array reference patterns (already correctly formatted)`);
}

// 6. Add export statement for easier importing
if (!content.includes('export type XiboEntity')) {
  // Find all interface definitions and create a union type for easier access
  const interfaceMatches = content.match(/export interface (\w+)/g);
  if (interfaceMatches) {
    const interfaceNames = interfaceMatches.map(match => match.replace('export interface ', ''));
    
    // Filter out generic types that require type parameters
    const genericTypes = ['PaginatedResponse', 'ApiResponse', 'XiboApiResponse', 'XiboPaginatedResponse'];
    const concreteTypes = interfaceNames.filter(name => !genericTypes.includes(name));
    
    const exportTypes = `
/**
 * Union type of all available Xibo CMS entities (concrete types only)
 */
export type XiboEntity = ${concreteTypes.join(' | ')};

/**
 * Map of entity names to their types for dynamic access
 */
export type XiboEntityMap = {
${concreteTypes.map(name => `  ${name}: ${name};`).join('\n')}
};
`;
    content += exportTypes;
    transformationCount++;
    console.log(`‚úÖ Added union types for ${concreteTypes.length} entities (excluded ${genericTypes.length} generic types)`);
  }
}

// 7. Add utility types for common patterns
const utilityTypes = `
/**
 * Utility types for Xibo CMS SDK
 */

/** Standard API response wrapper */
export interface XiboApiResponse<T> {
  data: T;
  total?: number;
  page?: number;
  pageSize?: number;
}

/** Paginated response type */
export interface XiboPaginatedResponse<T> extends XiboApiResponse<T[]> {
  hasNext: boolean;
  hasPrevious: boolean;
}

/** Common search parameters */
export interface XiboSearchParams {
  start?: number;
  length?: number;
  order?: string;
  sort?: string;
  search?: string;
}

/** Tag link structure used throughout the API */
export interface XiboTagLink {
  tag: string;
  tagId: number;
  value?: string;
}

/** Permission structure used throughout the API */
export interface XiboPermission {
  permissionId: number;
  entityId: number;
  groupId: number;
  objectId: number;
  view: boolean;
  edit: boolean;
  delete: boolean;
  modifyPermissions: boolean;
}
`;

if (!content.includes('XiboApiResponse')) {
  content += utilityTypes;
  transformationCount++;
  console.log('‚úÖ Added utility types for common patterns');
}

// Write the transformed content back to the file
fs.writeFileSync(TYPES_FILE, content, 'utf8');

console.log(`‚úÖ Post-processing completed with ${transformationCount} transformations`);
console.log(`üìù Updated file: ${TYPES_FILE}`);

// Verify the file is valid TypeScript by attempting to parse it
try {
  // Basic syntax validation - check for balanced braces
  const openBraces = (content.match(/{/g) || []).length;
  const closeBraces = (content.match(/}/g) || []).length;
  
  if (openBraces !== closeBraces) {
    console.warn(`‚ö†Ô∏è  Warning: Unbalanced braces detected (${openBraces} open, ${closeBraces} close)`);
  } else {
    console.log('‚úÖ Basic syntax validation passed');
  }
} catch (error) {
  console.error('‚ùå Syntax validation failed:', error.message);
  process.exit(1);
}

console.log('üéâ Post-processing completed successfully!');
